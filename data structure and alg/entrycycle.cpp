
///讨论一下为什么这种算法是可行的。 先通过快慢指针确定有环存在。当快慢指针相遇时，慢指针必然没有遍历完单链表的全部节点
///（如果单链表整体是环时，他们会在原点相遇，当单链表不全是环时，慢指针必然遍历不完单链表i）。
///快指针已经在环内走了n圈，假设快指针走了2m步，则慢指针走了m步。当两者相遇时，有2m = m +nr(r是指环的大小)，则 m = nr.
///设整个链表长L，环入口与相遇点的距离为x，起点到环入口的距离为a。
///则 a+x=nr,a+x=(n-1)r+r=(n-1)r+L-a,则 a=(n-1)r+(L-a-x).L-a-x就是相遇点与环入口的距离。即从链表头到环入口等于（n-1）环加上相遇点到换入口的距离。
///所以，当指针分别在环入口和相遇点开始前进时，两指针相遇处即为环入口。 
SListNode* SListCrossEntreNode(SListNode* list, SListNode* meetNode) //13.求环的入口点（环的入口点就是一个从链表开始另一个从相遇点开，当他们相交的点就是入口点）
{
	while (list!=meetNode)
	{
		list=list->next;
		meetNode=meetNode->next;
	}
	return list;
}
